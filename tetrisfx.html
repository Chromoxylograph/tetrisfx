<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris FX</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --background-color: #0a0a1e; /* Deeper space blue */
            --primary-text: #e0e0e0;
            --highlight-color: #ff33cc; /* Hot Pink */
            --secondary-highlight: #00ffff; /* Cyan */
            --border-color: #6a6a8a; /* Lighter border */
            --game-bg: rgba(0, 0, 15, 0.65); /* Darker, slightly blue bg */
            --grid-color: rgba(74, 74, 106, 0.2); /* Fainter grid */
            --ghost-color: rgba(255, 255, 255, 0.1); /* More subtle ghost */
            --level-up-pulse: #34e0a1;
            --pause-overlay: rgba(10, 10, 30, 0.9);
            --star-color: rgba(255, 255, 255, 0.7);
            --lose-overlay: rgba(30, 10, 10, 0.9); /* Dark red overlay for lose */
            --lose-highlight: #ff3333; /* Red highlight for lose screen */

            /* Base Piece Colors (for effects) */
            --color-i-base1: #00ffff; --color-i-base2: #00cccc;
            --color-o-base1: #ffff00; --color-o-base2: #cccc00;
            --color-t-base1: #cc00ff; --color-t-base2: #9900cc;
            --color-s-base1: #00ff00; --color-s-base2: #00cc00;
            --color-z-base1: #ff0000; --color-z-base2: #cc0000;
            --color-j-base1: #0000ff; --color-j-base2: #0000cc;
            --color-l-base1: #ffaa00; --color-l-base2: #cc8800;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Press Start 2P', cursive;
            background-color: var(--background-color);
            color: var(--primary-text);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            perspective: 1000px;
        }

        .container {
             border: none;
             padding: 15px;
             background-color: rgba(20, 20, 40, 0.7);
             border-radius: 15px;
             box-shadow: 0 0 40px rgba(0, 255, 255, 0.3), 0 0 20px rgba(255, 51, 204, 0.3);
             position: relative;
             transition: background-color 0.3s ease, box-shadow 0.3s ease;
             display: flex;
             flex-direction: column;
             align-items: center;
        }

        h1 { /* Overall Game Title */
            color: var(--highlight-color);
            margin-bottom: 15px;
            text-shadow: 3px 3px 0px #000, 0 0 10px var(--secondary-highlight), 0 0 20px var(--secondary-highlight);
            text-align: center;
            font-size: 2.2em;
            animation: pulse-glow 2s infinite alternate;
            display: block; /* Always visible unless game area is shown (handled by CSS/layout) */
        }

        @keyframes pulse-glow {
           from { text-shadow: 3px 3px 0px #000, 0 0 10px var(--secondary-highlight), 0 0 20px var(--secondary-highlight); }
           to { text-shadow: 3px 3px 0px #000, 0 0 20px var(--highlight-color), 0 0 40px var(--highlight-color); }
        }

        /* Game Area */
        .game-area {
            display: none; /* Controlled by JS */
            gap: 20px;
            margin-top: 15px;
            position: relative;
        }

        .canvas-container {
            position: relative;
             border: 3px solid var(--border-color);
             box-shadow: 0 0 15px var(--secondary-highlight), inset 0 0 15px rgba(0,0,0,0.7);
             border-radius: 5px;
        }
        .canvas-container::before {
             content: ''; position: absolute; top: -5px; left: -5px; right: -5px; bottom: -5px;
             border-radius: 8px; border: 2px solid transparent;
             box-shadow: 0 0 20px var(--highlight-color), inset 0 0 10px var(--highlight-color);
             z-index: -1; animation: border-glow 3s infinite linear; pointer-events: none;
        }
        @keyframes border-glow {
            0% { box-shadow: 0 0 15px var(--highlight-color), inset 0 0 8px var(--highlight-color); }
            50% { box-shadow: 0 0 25px var(--secondary-highlight), inset 0 0 12px var(--secondary-highlight); }
            100% { box-shadow: 0 0 15px var(--highlight-color), inset 0 0 8px var(--highlight-color); }
        }


        #gameCanvas { display: block; background-color: transparent; position: relative; z-index: 1; border-radius: 3px; }
        #particleCanvas { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 5; }

        .side-panel { display: flex; flex-direction: column; gap: 12px; width: 140px; font-size: 0.75em; text-align: center; }
        .info-box { background-color: rgba(0, 0, 0, 0.4); border: 1px solid var(--border-color); padding: 8px; border-radius: 5px; box-shadow: inset 0 0 8px rgba(0,0,0,0.7); }
        .info-box h3 { color: var(--secondary-highlight); margin-bottom: 8px; font-size: 0.9em; text-shadow: 1px 1px 0 #000; }
        #nextCanvas, #holdCanvas { border: 1px solid var(--border-color); background-color: rgba(0, 0, 15, 0.6); display: block; margin: 4px auto 0; box-shadow: inset 0 0 5px rgba(0,0,0,0.5); border-radius: 3px; }
        #score, #level, #lines, #highScore { color: #fff; font-weight: bold; font-size: 1.1em; text-shadow: 0 0 3px var(--highlight-color); }

        /* Screens */
         .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--pause-overlay); /* Default background */
            display: flex; flex-direction: column;
            justify-content: center; align-items: center; text-align: center;
            z-index: 10; opacity: 0; visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s ease;
            border-radius: 15px; padding: 20px; box-sizing: border-box;
         }
         #mainMenu, #settingsMenu, #gameOverScreen, #winScreen, #pauseOverlay { display: none; }
         .screen.active { display: flex; opacity: 1; visibility: visible; }

         /* Titles for OTHER screens */
         #settingsMenu h2, #winScreen h2, #pauseOverlay h2 {
             color: var(--highlight-color);
             margin-bottom: 25px;
             text-shadow: 2px 2px 0px #000, 0 0 10px var(--secondary-highlight);
             font-size: 2em;
         }

        /* Specific Lose Screen Title */
         #gameOverScreen h2 {
             color: var(--lose-highlight);
             margin-bottom: 25px;
             text-shadow: 2px 2px 0px #000, 0 0 10px #ff0000, 0 0 20px var(--lose-highlight); /* Red shadow */
             font-size: 2em;
             animation: flicker 1.5s infinite alternate;
         }

         #gameOverScreen {
             background-color: var(--lose-overlay); /* Use the dark red overlay */
         }

         @keyframes flicker {
            0%, 18%, 22%, 25%, 53%, 57%, 100% {
                text-shadow:
                    2px 2px 0px #000,
                    0 0 10px #ff0000,
                    0 0 20px var(--lose-highlight),
                    0 0 30px var(--lose-highlight),
                    0 0 40px var(--lose-highlight);
                opacity: 1;
            }
            20%, 24%, 55% {
                text-shadow: none;
                opacity: 0.7;
            }
         }

        /* Buttons */
         button, .button {
             font-family: 'Press Start 2P', cursive; background-color: var(--highlight-color); color: #000;
             border: none; padding: 12px 25px; font-size: 1em; cursor: pointer;
             border-radius: 5px; margin: 8px 0; transition: all 0.2s ease;
             box-shadow: 0 4px 0 #a11a5a; text-transform: uppercase; text-shadow: none;
         }
         button:hover, .button:hover { background-color: #ff4dab; transform: translateY(-2px); box-shadow: 0 6px 0 #a11a5a; color: #000; }
         button:active, .button:active { transform: translateY(2px); box-shadow: 0 2px 0 #a11a5a; }
         button.secondary { background-color: var(--secondary-highlight); box-shadow: 0 4px 0 #00aaaa; color: #000; }
         button.secondary:hover { background-color: #6fffe9; box-shadow: 0 6px 0 #00aaaa; color: #000;}
         button.secondary:active { box-shadow: 0 2px 0 #00aaaa; }

         /* Effects Styling */
          .screen-shake { animation: shake 0.25s cubic-bezier(.36,.07,.19,.97) both; }
          @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0) rotate(-1deg); } 20%, 80% { transform: translate3d(2px, 0, 0) rotate(1deg); } 30%, 50%, 70% { transform: translate3d(-3px, 0, 0) rotate(-2deg); } 40%, 60% { transform: translate3d(3px, 0, 0) rotate(2deg); } 100% { transform: translate3d(0,0,0) rotate(0); } }
          .level-pulse { animation: pulse-bg 0.6s ease-out; }
          @keyframes pulse-bg { /* Target .container style */ 0%, 70% { background-color: var(--level-up-pulse); box-shadow: 0 0 30px var(--level-up-pulse), 0 0 15px var(--level-up-pulse); } 100% { background-color: rgba(20, 20, 40, 0.7); box-shadow: 0 0 40px rgba(0, 255, 255, 0.3), 0 0 20px rgba(255, 51, 204, 0.3); } }
          #flashOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: white; opacity: 0; z-index: 8; pointer-events: none; transition: opacity 0.1s ease-out; }
          #flashOverlay.active { opacity: 0.6; }

        /* Settings specific styles */
         .settings-group { margin-bottom: 20px; width: 80%; max-width: 300px; }
         .settings-group label { display: block; margin-bottom: 10px; color: var(--primary-text); }
         .settings-group div { display: flex; justify-content: center; align-items: center; }
         .settings-group input[type="radio"] { margin: 0 5px 0 15px; transform: scale(1.2); accent-color: var(--highlight-color); }
         .settings-group input[type="radio"] + label { display: inline-block; color: var(--primary-text); font-size: 0.9em; cursor: pointer;}

    </style>
</head>
<body>
    <div class="container" id="gameContainer">
        <!-- Overall Game Title -->
        <h1>Tetris FX</h1>

        <!-- Screens -->
        <div id="mainMenu" class="screen active">
            <!-- Title Removed -->
            <button id="startButton">Start Game</button>
            <button id="settingsButton" class="secondary">Settings</button>
            <div class="info-box" style="margin-top: 15px; background: transparent; border: none; box-shadow: none;">
                <h3>High Score</h3>
                <span id="menuHighScore">0</span>
            </div>
        </div>

        <div id="settingsMenu" class="screen">
             <h2>Settings</h2>
             <div class="settings-group">
                 <label for="controls">Controls:</label>
                 <div>
                     <input type="radio" id="controlsArrows" name="controls" value="arrows" checked>
                     <label for="controlsArrows">Arrow Keys</label>
                     <input type="radio" id="controlsWASD" name="controls" value="wasd">
                     <label for="controlsWASD">WASD</label>
                 </div>
             </div>
             <button id="saveSettingsButton" class="secondary">Back to Menu</button>
         </div>

        <div id="gameOverScreen" class="screen">
            <h2>YOU LOSE!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p style="margin-top:10px">Level Reached: <span id="finalLevel">1</span></p>
            <div class="info-box" style="margin: 20px 0; background: transparent; border: none; box-shadow: none;">
                 <h3>High Score</h3>
                 <span id="gameOverHighScore">0</span>
             </div>
            <button id="restartButton">Play Again</button>
            <button id="backToMenuButtonGO" class="secondary">Main Menu</button>
        </div>

        <div id="winScreen" class="screen">
            <h2>YOU WIN!</h2>
             <p>You conquered level 100!</p>
            <p>Final Score: <span id="winScore">0</span></p>
             <div class="info-box" style="margin: 20px 0; background: transparent; border: none; box-shadow: none;">
                 <h3>High Score</h3>
                 <span id="winHighScore">0</span>
             </div>
            <button id="playAgainWinButton">Play Again</button>
            <button id="backToMenuButtonWin" class="secondary">Main Menu</button>
        </div>

         <div id="pauseOverlay" class="screen">
             <h2>PAUSED</h2>
             <button id="resumeButton">Resume (P)</button>
             <button id="exitToMenuPausedButton" class="secondary">Exit to Menu</button>
         </div>


        <!-- Game Area -->
        <div class="game-area" id="gameArea">
             <div class="canvas-container">
                 <canvas id="gameCanvas"></canvas>
                 <canvas id="particleCanvas"></canvas>
                 <div id="flashOverlay"></div>
            </div>
            <div class="side-panel">
                <div class="info-box"><h3>Score</h3><span id="score">0</span></div>
                <div class="info-box"><h3>Level</h3><span id="level">1</span></div>
                <div class="info-box"><h3>Lines</h3><span id="lines">0</span></div>
                <div class="info-box"><h3>High Score</h3><span id="highScore">0</span></div>
                <div class="info-box">
                     <h3>Hold (C)</h3>
                     <canvas id="holdCanvas"></canvas>
                 </div>
                <div class="info-box">
                    <h3>Next</h3>
                    <canvas id="nextCanvas"></canvas>
                </div>
                 <div style="margin-top:auto;">
                    <button id="pauseButton" class="secondary">Pause (P)</button>
                 </div>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const holdCanvas = document.getElementById('holdCanvas');
        const holdCtx = holdCanvas.getContext('2d');
        const flashOverlay = document.getElementById('flashOverlay');
        const gameContainer = document.getElementById('gameContainer');
        const gameCanvas = document.getElementById('gameCanvas');
        const nextCanvas = document.getElementById('nextCanvas');
        const particleCanvas = document.getElementById('particleCanvas');
        const ctx = gameCanvas.getContext('2d');
        const nextCtx = nextCanvas.getContext('2d');
        const particleCtx = particleCanvas.getContext('2d');

        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const linesElement = document.getElementById('lines');
        const highScoreElement = document.getElementById('highScore');
        const menuHighScoreElement = document.getElementById('menuHighScore');
        const gameOverHighScoreElement = document.getElementById('gameOverHighScore');
        const winHighScoreElement = document.getElementById('winHighScore');

        const mainMenu = document.getElementById('mainMenu');
        const settingsMenu = document.getElementById('settingsMenu');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const winScreen = document.getElementById('winScreen');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const gameArea = document.getElementById('gameArea');

        const finalScoreElement = document.getElementById('finalScore');
        const finalLevelElement = document.getElementById('finalLevel');
        const winScoreElement = document.getElementById('winScore');

        const startButton = document.getElementById('startButton');
        const settingsButton = document.getElementById('settingsButton');
        const saveSettingsButton = document.getElementById('saveSettingsButton');
        const restartButton = document.getElementById('restartButton');
        const playAgainWinButton = document.getElementById('playAgainWinButton');
        const backToMenuButtonGO = document.getElementById('backToMenuButtonGO');
        const backToMenuButtonWin = document.getElementById('backToMenuButtonWin');
        const pauseButton = document.getElementById('pauseButton');
        const resumeButton = document.getElementById('resumeButton');
        const exitToMenuPausedButton = document.getElementById('exitToMenuPausedButton');

        const controlsArrowsRadio = document.getElementById('controlsArrows');
        const controlsWASDRadio = document.getElementById('controlsWASD');

        // --- Game Constants & Setup ---
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 32;
        const NEXT_COLS = 4; const NEXT_ROWS = 4;
        const HOLD_COLS = 4; const HOLD_ROWS = 4;
        const WIN_LEVEL = 100;
        const STAR_COUNT = 150;

        const shapes = {
            'I': [[1, 1, 1, 1]], 'O': [[1, 1], [1, 1]], 'T': [[0, 1, 0], [1, 1, 1]],
            'S': [[0, 1, 1], [1, 1, 0]], 'Z': [[1, 1, 0], [0, 1, 1]], 'J': [[1, 0, 0], [1, 1, 1]],
            'L': [[0, 0, 1], [1, 1, 1]]
        };
        const pieceTypes = Object.keys(shapes);
        let basePieceColors = {};

        // --- Game State Variables ---
        let board, currentPiece, nextPiece, holdPiece = null, canHold = true;
        let score, level, linesCleared, highScore;
        let dropCounter, dropInterval, lastTime, globalTime = 0;
        let gameOver, gameWon, isPaused;
        let controlScheme = 'arrows';
        let animationFrameId, currentScreen = 'mainMenu';
        let particles = [], stars = [];
        let GHOST_COLOR, GRID_COLOR, STAR_COLOR;


        // --- Initialization ---
        function initGame() {
            const style = getComputedStyle(document.body);
            GHOST_COLOR = style.getPropertyValue('--ghost-color').trim();
            GRID_COLOR = style.getPropertyValue('--grid-color').trim();
            STAR_COLOR = style.getPropertyValue('--star-color').trim();
            for(const type of pieceTypes) {
                 basePieceColors[type] = {
                     c1: style.getPropertyValue(`--color-${type.toLowerCase()}-base1`).trim(),
                     c2: style.getPropertyValue(`--color-${type.toLowerCase()}-base2`).trim()
                 };
             }

            gameCanvas.width = COLS * BLOCK_SIZE; gameCanvas.height = ROWS * BLOCK_SIZE;
            particleCanvas.width = gameCanvas.width; particleCanvas.height = gameCanvas.height;
            particleCanvas.style.position = 'absolute'; particleCanvas.style.top = '0'; particleCanvas.style.left = '0';
            nextCanvas.width = NEXT_COLS * BLOCK_SIZE; nextCanvas.height = NEXT_ROWS * BLOCK_SIZE;
            holdCanvas.width = HOLD_COLS * BLOCK_SIZE; holdCanvas.height = HOLD_ROWS * BLOCK_SIZE;

            nextCtx.scale(BLOCK_SIZE, BLOCK_SIZE); holdCtx.scale(BLOCK_SIZE, BLOCK_SIZE);

            loadHighScore(); initStars(STAR_COUNT); showScreen('mainMenu'); updateHighScoreDisplay();
        }

        function initStars(count) {
            stars = [];
            for (let i = 0; i < count; i++) stars.push({x: Math.random()*gameCanvas.width, y: Math.random()*gameCanvas.height, size: Math.random()*1.5+0.5, speed: Math.random()*20+10, opacity: Math.random()*0.5+0.3});
        }

        function resetGame() {
             board = createBoard(COLS, ROWS); score = 0; level = 1; linesCleared = 0; dropCounter = 0; gameOver = false; gameWon = false; isPaused = false;
             particles = []; clearParticleCanvas(); holdPiece = null; canHold = true; updateHoldPieceDisplay();
             if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null;
             nextPiece = getRandomPiece(); spawnNewPiece(); updateDropInterval(); updateUI(); drawNextPiece();
             globalTime = 0; lastTime = performance.now();
         }

         // --- Game Loop ---
         function gameLoop(timestamp = 0) {
              // Stop loop condition check moved inside endGame/winGame/togglePause for clarity
              if (!lastTime) lastTime = timestamp; const deltaTime = Math.min(timestamp - lastTime, 100); lastTime = timestamp; globalTime += deltaTime / 1000;
              dropCounter += deltaTime; if (dropCounter > dropInterval) playerDrop();
              updateStars(deltaTime / 1000); updateParticles(deltaTime / 1000); draw();

              // Request next frame *conditionally*
              if (!gameOver && !gameWon && !isPaused) {
                  animationFrameId = requestAnimationFrame(gameLoop);
              } else {
                  animationFrameId = null; // Ensure it's null if loop stops
              }
         }

        // --- Screen Management ---
        function showScreen(screenName) {
            currentScreen = screenName;
            const screens = [mainMenu, settingsMenu, gameOverScreen, winScreen, pauseOverlay];
            gameArea.style.display = 'none'; // Hide game area by default when showing a screen overlay
            screens.forEach(s => {
                s.classList.remove('active');
                s.style.display = 'none'; // Ensure all screens are hidden first
            });

            // Stop game loop if switching away from game/pause screen
            // Note: Loop stopping is primarily handled in endGame/winGame/togglePause now
            if (screenName !== 'game' && screenName !== 'pauseOverlay' && animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            let targetElement = null;
            switch(screenName) {
                case 'mainMenu':
                    targetElement = mainMenu;
                    break;
                case 'settings':
                    targetElement = settingsMenu;
                    break;
                case 'gameOver':
                    targetElement = gameOverScreen;
                    // Update score/level display *before* showing
                    finalScoreElement.textContent = score;
                    finalLevelElement.textContent = level;
                    updateHighScoreDisplay(); // Also update HS display here
                    break; // Don't forget break!
                case 'win':
                    targetElement = winScreen;
                    winScoreElement.textContent = score;
                    updateHighScoreDisplay(); // Also update HS display here
                    break; // Don't forget break!
                case 'pauseOverlay':
                    targetElement = pauseOverlay;
                    gameArea.style.display = 'flex'; // Keep game area visible UNDER the pause overlay
                    break;
                case 'game':
                    gameArea.style.display = 'flex'; // Show game area
                    updateHighScoreDisplay();
                    // The game loop should be started/resumed elsewhere (startGameLoop/togglePause)
                    return; // Exit early for game screen
            }

            // Common logic to show the target screen element
            if(targetElement) {
                targetElement.style.display = 'flex'; // Make it visible
                targetElement.offsetHeight; // Force reflow for transition
                targetElement.classList.add('active'); // Add active class for opacity/visibility transition
            }

            // Update high score display on menu/end screens
            if (screenName !== 'game' && screenName !== 'pauseOverlay') {
                updateHighScoreDisplay();
            }
        }


        // --- Hold Piece Logic ---
        function playerHold() {
            if (!canHold || isPaused || gameOver || gameWon) return; canHold = false;
            const previouslyHeld = holdPiece; const currentType = currentPiece.type;
            holdPiece = { type: currentType, shape: shapes[currentType] };
            if (previouslyHeld) {
                 currentPiece = getRandomPiece(); // Get new obj instance
                 currentPiece.type = previouslyHeld.type; currentPiece.shape = shapes[previouslyHeld.type]; currentPiece.color = basePieceColors[previouslyHeld.type];
                 currentPiece.x = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2); currentPiece.y = 0;
                 if (collision(board, currentPiece)) {
                     // Don't call endGame directly here, let spawnNewPiece handle it
                     // Force game over immediately since swapping back caused collision
                     gameOver = true;
                     endGame(); // Now call endGame as the game is truly over
                     return;
                 }
            } else {
                // Spawning the next piece after holding for the first time
                spawnNewPiece();
            }
            updateHoldPieceDisplay();
            // Only redraw if the game isn't immediately over
            if (!gameOver && !gameWon && !isPaused) draw();
        }


        // --- Game Logic Functions ---
        function createBoard(cols, rows) { return Array.from({ length: rows }, () => Array(cols).fill(0)); }
        function getRandomPiece() {
             const type = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
             return { type: type, shape: shapes[type], color: basePieceColors[type], x: Math.floor(COLS / 2) - Math.floor(shapes[type][0].length / 2), y: 0 };
        }
        function spawnNewPiece() {
            // Check for game over *before* assigning the new piece
            if (gameOver) return; // Already ended

            currentPiece = nextPiece;
            currentPiece.x = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2);
            currentPiece.y = 0;
            canHold = true; // Allow holding again
            nextPiece = getRandomPiece();
            drawNextPiece();

            // Check for collision *after* placing the new piece
            if (collision(board, currentPiece)) {
                gameOver = true;
                endGame(); // Call endGame here, as the new piece caused the loss
            }
        }
        function playerDrop() { if (!currentPiece || isPaused || gameOver || gameWon) return; currentPiece.y++; if (collision(board, currentPiece)) { currentPiece.y--; lockPiece(); } dropCounter = 0; }
        function playerMove(dir) { if (!currentPiece || isPaused || gameOver || gameWon) return; currentPiece.x += dir; if (collision(board, currentPiece)) currentPiece.x -= dir; }
        function rotate(matrix) { const rows = matrix.length, cols = matrix[0].length; const newMatrix = Array.from({ length: cols }, () => Array(rows)); for (let i = 0; i < rows; i++) for (let j = 0; j < cols; j++) newMatrix[j][rows - 1 - i] = matrix[i][j]; return newMatrix; }
        function playerRotate() {
             if (!currentPiece || isPaused || gameOver || gameWon) return;
             const oX = currentPiece.x; const oS = currentPiece.shape; let rS = rotate(oS); currentPiece.shape = rS;
             let offset = 1;
             while (collision(board, currentPiece)) {
                  currentPiece.x += offset; offset = -(offset + (offset > 0 ? 1 : -1));
                  const shapeW = currentPiece.shape[0]?.length || 1;
                  // Adjust wall kick limit slightly based on piece width
                  if (Math.abs(offset) > Math.max(shapeW, 2)) {
                      currentPiece.shape = oS;
                      currentPiece.x = oX;
                      return; // Rotation failed
                  }
              }
              // Rotation successful, may need redraw
              if(!gameOver && !gameWon && !isPaused) draw();
        }
         function hardDrop() {
             if (!currentPiece || isPaused || gameOver || gameWon) return;
             let ghostY = currentPiece.y; let dist = 0;
             while (!collision(board, {...currentPiece, y: ghostY + 1})) { ghostY++; dist++; }
             if (dist > 0) { currentPiece.y = ghostY; score += dist * 2; } // Only score if moved
             // Lock piece immediately after hard drop
             lockPiece();
             // Only reset drop timer if game continues
             if (!gameOver && !gameWon) {
                 // --- REMOVED screen shake from here ---
                 // triggerScreenShake(0.2, 5);
                 dropCounter = dropInterval; // Reset drop timer
             }
         }
        function collision(board, piece) {
             if (!piece || !piece.shape) return false; // Safety check
             for (let y = 0; y < piece.shape.length; y++) {
                 for (let x = 0; x < piece.shape[y].length; x++) {
                     if (piece.shape[y][x]) { // If it's part of the piece shape
                         const bX = piece.x + x;
                         const bY = piece.y + y;
                         // Check boundaries
                         if (bX < 0 || bX >= COLS || bY >= ROWS) return true;
                         // Check collision with existing blocks (only if within board bounds vertically)
                         if (bY >= 0 && board[bY]?.[bX]) return true;
                     }
                 }
             }
             return false; // No collision detected
         }
        function lockPiece() {
             // Check if already game over or if there's no current piece
             if (gameOver || !currentPiece) return;

             flashPiece(currentPiece);
             spawnLockParticles(currentPiece, 30);

             // Merge the piece into the board
             currentPiece.shape.forEach((row, y) => {
                 row.forEach((value, x) => {
                     if (value) {
                         const bY = currentPiece.y + y;
                         const bX = currentPiece.x + x;
                         // Important: Check if the piece locked partially or fully above the top
                         if (bY < 0) {
                             gameOver = true; // Piece locked above the visible area
                             // No need to merge this part, but trigger game over
                         } else if (bY < ROWS && bX >= 0 && bX < COLS) {
                             board[bY][bX] = currentPiece.type;
                         }
                     }
                 });
             });

             // If game over was triggered by locking above the board, end the game
             if (gameOver) {
                 currentPiece = null; // Clear the piece
                 endGame();
                 return; // Stop further processing
             }

             currentPiece = null; // Piece is now locked, clear currentPiece
             clearLines(); // Clear lines and check for win condition

             // Only spawn a new piece if the game hasn't ended (by clearLines or win)
             if (!gameOver && !gameWon) {
                 spawnNewPiece();
             } else if (gameOver && !animationFrameId) {
                 // If clearLines somehow triggered gameOver (shouldn't happen), ensure endGame runs
                 endGame();
             }
         }
        function flashPiece(piece) {
            if (!piece || isPaused || gameOver || gameWon) return; // Added gameOver/gameWon check
            const dur = 80;
            const tempP = {...piece, color: { c1: 'white', c2: '#dddddd' }};
            // Ensure piece is drawn only if game is active
            if (!isPaused && !gameOver && !gameWon) {
                 drawPieceOnBoard(tempP, ctx);
                 // The setTimeout here doesn't really pause execution,
                 // it just schedules the empty function to run later.
                 // The visual flash relies on the next draw cycle overwriting it.
                 setTimeout(()=>{
                     // Redraw needed after flash? Handled by main loop or subsequent draw calls.
                 }, dur);
             }
        }
        function clearLines() {
             let clearedCount = 0;
             let actualClearedIndices = []; // Store the original indices for effects

             // Iterate from bottom up to handle multiple clears correctly
             for (let y = ROWS - 1; y >= 0; y--) {
                 let isFull = true;
                 for (let x = 0; x < COLS; x++) {
                     if (!board[y][x]) {
                         isFull = false;
                         break;
                     }
                 }

                 if (isFull) {
                     actualClearedIndices.push(y); // Store original index
                     // Remove the row
                     board.splice(y, 1);
                     // Add a new empty row at the top
                     board.unshift(new Array(COLS).fill(0));
                     clearedCount++;
                     y++; // Re-check the current index because rows below shifted up
                 }
             }


             if (clearedCount > 0) {
                  // Trigger particle and shake effects *once* after all lines in the batch are processed
                  triggerLineClearEffect(clearedCount, actualClearedIndices);

                  linesCleared += clearedCount;
                  let basePts = [0, 100, 300, 500, 800]; // Score for 1, 2, 3, 4 lines
                  // Score based on how many lines cleared *at once*
                  score += (basePts[clearedCount] || basePts[4]) * level; // Use basePts[4] for 4+ lines

                  let prevLvl = level;
                  level = Math.floor(linesCleared / 10) + 1;
                  if (level > prevLvl) {
                      updateDropInterval();
                      gameContainer.classList.add('level-pulse');
                      setTimeout(()=>gameContainer.classList.remove('level-pulse'), 600);
                  }

                  // Check win condition
                  if (level >= WIN_LEVEL && !gameWon) {
                      gameWon = true;
                      winGame(); // Transition to win state
                      return; // Stop further processing if won
                  }

                  // Update UI only if game continues
                  if (!gameOver && !gameWon) {
                     updateUI();
                  }
              }
         }
         // Now receives the TOTAL count of lines cleared in this batch
         function triggerLineClearEffect(totalClearedCount, rowIndices) {
              const isTetris = totalClearedCount >= 4;
              const partsPerLine = 75; // Standard particles per line

              // Spawn particles for each cleared row index
              rowIndices.forEach(idx => {
                  let fakeRow = Array(COLS).fill(pieceTypes[Math.floor(Math.random() * pieceTypes.length)]);
                  spawnLineClearParticles(idx, fakeRow, partsPerLine);
              });

              // Flash effect - maybe longer/brighter for Tetris?
              flashOverlay.style.backgroundColor = isTetris ? 'cyan' : 'white';
              flashOverlay.classList.add('active');
              setTimeout(() => flashOverlay.classList.remove('active'), isTetris ? 150 : 100); // Slightly longer flash for tetris

              // --- Screen Shake based on total lines cleared ---
              if (isTetris) triggerScreenShake(0.4, 12);
              else if (totalClearedCount === 3) triggerScreenShake(0.3, 8);
              else if (totalClearedCount === 2) triggerScreenShake(0.2, 5);
              else if (totalClearedCount === 1) triggerScreenShake(0.15, 3);
         }
        function updateDropInterval() { dropInterval = Math.max(50, 900 - (level - 1) * 12); } // Speed caps at level ~71
        function updateUI() {
            // Only update if elements exist
            if(scoreElement) scoreElement.textContent = score;
            if(levelElement) levelElement.textContent = level;
            if(linesElement) linesElement.textContent = linesCleared;
            updateHighScoreDisplay(); // Update all HS displays
        }
        function updateStars(dt) { stars.forEach(s => { s.y += s.speed * dt; s.opacity = Math.max(0.1, Math.min(0.9, s.opacity + (Math.random() - 0.5) * 0.2)); if (s.y > gameCanvas.height) { s.y = 0; s.x = Math.random() * gameCanvas.width; } }); }

        // --- Drawing ---
        function draw() {
             // Don't draw if game hasn't started or is truly over
             if (currentScreen !== 'game' && currentScreen !== 'pauseOverlay') return;

             ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
             drawStarfield();
             drawGrid();
             drawBoard();

             // Only draw ghost and current piece if game is active and not paused
             if (!isPaused && !gameOver && !gameWon) {
                 if (currentPiece) drawGhostPiece();
                 if (currentPiece) drawPieceOnBoard(currentPiece, ctx);
             }

             // Always draw particles
             clearParticleCanvas();
             drawParticles();
        }
        function drawStarfield() { ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--background-color').trim(); ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height); ctx.save(); stars.forEach(s => { ctx.fillStyle = STAR_COLOR; ctx.globalAlpha = s.opacity; ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2); ctx.fill(); }); ctx.restore(); }
        function drawGrid() { ctx.strokeStyle = GRID_COLOR; ctx.lineWidth = 1; ctx.beginPath(); for (let i = 1; i < COLS; i++) { ctx.moveTo(i * BLOCK_SIZE, 0); ctx.lineTo(i * BLOCK_SIZE, ROWS * BLOCK_SIZE); } for (let i = 1; i < ROWS; i++) { ctx.moveTo(0, i * BLOCK_SIZE); ctx.lineTo(COLS * BLOCK_SIZE, i * BLOCK_SIZE); } ctx.stroke(); }
        function drawBoard() { for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) if (board[y][x]) drawBlock(x, y, basePieceColors[board[y][x]].c1, basePieceColors[board[y][x]].c2, ctx); }
        function drawPieceOnBoard(piece, canvasContext) { if (!piece || !piece.shape) return; const isG = (piece.color === GHOST_COLOR); const cInfo = isG ? { c1: GHOST_COLOR, c2: GHOST_COLOR } : piece.color; piece.shape.forEach((r, y) => r.forEach((v, x) => { if (v) drawBlock(piece.x + x, piece.y + y, cInfo.c1, cInfo.c2, canvasContext, isG); })); }
        function drawBlock(x, y, color1, color2, ctx, isGhost = false) {
              // Ensure block is within visible canvas bounds before drawing
              if (y < 0) return;
              const drawX = x * BLOCK_SIZE, drawY = y * BLOCK_SIZE, size = BLOCK_SIZE;
              if (isGhost) { ctx.fillStyle = GHOST_COLOR; ctx.fillRect(drawX, drawY, size, size); ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 1; ctx.strokeRect(drawX+0.5, drawY+0.5, size-1, size-1); return; }
              const timeF = Math.sin(globalTime*3 + x*0.3 + y*0.2)*0.4+0.5; const grad = ctx.createLinearGradient(drawX, drawY, drawX+size, drawY+size);
              grad.addColorStop(Math.max(0, timeF-0.1), color1); grad.addColorStop(timeF, color2); grad.addColorStop(Math.min(1, timeF+0.1), color1);
              ctx.fillStyle = grad; ctx.fillRect(drawX, drawY, size, size);
              ctx.strokeStyle='rgba(0,0,0,0.3)'; ctx.lineWidth=1; ctx.strokeRect(drawX+1.5, drawY+1.5, size-3, size-3);
              ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.strokeRect(drawX+0.5, drawY+0.5, size-1, size-1);
         }
        function drawGhostPiece() { if (!currentPiece) return; const gp = {...currentPiece}; gp.shape = currentPiece.shape; gp.color = GHOST_COLOR; gp.y = currentPiece.y; while(!collision(board, {...gp, y: gp.y + 1})) { gp.y++; } drawPieceOnBoard(gp, ctx); } // Simplified ghost logic slightly
        function drawPreviewPiece(pieceInfo, pCtx) {
            pCtx.save(); pCtx.setTransform(1,0,0,1,0,0); pCtx.clearRect(0,0,pCtx.canvas.width, pCtx.canvas.height); pCtx.restore();
            const bgSt = window.getComputedStyle(pCtx.canvas).backgroundColor || 'rgba(0,0,15,0.6)'; pCtx.fillStyle = bgSt; pCtx.fillRect(0, 0, pCtx.canvas.width / BLOCK_SIZE, pCtx.canvas.height / BLOCK_SIZE);
            if (!pieceInfo) return; const shape = pieceInfo.shape; const cInfo = basePieceColors[pieceInfo.type]; const sW=shape[0].length; const sH=shape.length;
            const gridW=pCtx.canvas.width/BLOCK_SIZE; const gridH=pCtx.canvas.height/BLOCK_SIZE; const offX=(gridW-sW)/2; const offY=(gridH-sH)/2;
            shape.forEach((r, y)=>r.forEach((v,x)=>{ if(v){ const dX=offX+x, dY=offY+y; pCtx.fillStyle = cInfo.c1; pCtx.fillRect(dX, dY, 1, 1); pCtx.strokeStyle='rgba(0,0,0,0.5)'; pCtx.lineWidth=0.05; pCtx.strokeRect(dX+0.02, dY+0.02, 0.96, 0.96); }}));
        }
        function drawNextPiece() { drawPreviewPiece(nextPiece ? { type: nextPiece.type, shape: nextPiece.shape } : null, nextCtx); }
        function updateHoldPieceDisplay() { drawPreviewPiece(holdPiece, holdCtx); }

        // --- Particle Effects ---
         function createParticle(x, y, color, life, angle, speed, gravity = false, type = 'circle') { return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, size: Math.random() * 4 + 2, color, life, maxLife: life, gravity, type, alpha: 1 }; }
         function spawnLineClearParticles(rowIdx, rowData, countPerLine) { const pY = (rowIdx+0.5)*BLOCK_SIZE; const blocks=rowData.filter(t=>t).length||1; const cpp = Math.ceil(countPerLine/blocks); for (let x=0; x<COLS; x++) { if(rowData[x]){ const pX = (x+0.5)*BLOCK_SIZE; const cI = basePieceColors[rowData[x]]; for(let i=0;i<cpp;i++){ const ang = Math.random()*Math.PI*2; const spd=Math.random()*150+80; const lf=Math.random()*0.8+0.5; const clr=Math.random()>0.5?cI.c1:cI.c2; particles.push(createParticle(pX,pY,clr,lf,ang,spd,true)); }}}}
         function spawnLockParticles(piece, count) { if(!piece)return; const cI=piece.color; const blocks=piece.shape.flat().filter(v=>v).length||1; const cpp=Math.ceil(count/blocks); piece.shape.forEach((r,y)=>r.forEach((v,x)=>{if(v){const bX=(piece.x+x+0.5)*BLOCK_SIZE;const bY=(piece.y+y+0.5)*BLOCK_SIZE;for(let i=0;i<cpp;i++){const clr=Math.random()>0.5?cI.c1:cI.c2;particles.push(createParticle(bX,bY,clr,Math.random()*0.4+0.2,Math.random()*Math.PI*2,Math.random()*60+30));}}}))}
         function updateParticles(dt) { const grav=300*dt; for(let i=particles.length-1;i>=0;i--){const p=particles[i];p.life-=dt; if(p.life<=0)particles.splice(i,1); else{p.x+=p.vx*dt; p.y+=p.vy*dt; if(p.gravity)p.vy+=grav; p.alpha=Math.max(0,p.life/p.maxLife);}}}
         function clearParticleCanvas() { particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height); }
         function drawParticles() { particles.forEach(p=>{ particleCtx.fillStyle=p.color; particleCtx.globalAlpha=p.alpha; particleCtx.beginPath(); if(p.type==='circle'){particleCtx.arc(p.x, p.y, p.size*0.5*Math.max(0.2, p.alpha), 0, Math.PI*2);} else {const s=p.size*Math.max(0.2, p.alpha); particleCtx.fillRect(p.x-s/2, p.y-s/2, s, s);} particleCtx.fill(); }); particleCtx.globalAlpha=1.0; }
         function triggerScreenShake(duration = 0.15, intensity = 5) { gameCanvas.classList.remove('screen-shake'); void gameCanvas.offsetWidth; gameCanvas.classList.add('screen-shake'); setTimeout(()=>gameCanvas.classList.remove('screen-shake'), duration*1000); }

        // --- High Score ---
        function loadHighScore() { highScore = parseInt(localStorage.getItem('ultraInsaneTetrisHighScore') || '0'); }
        function saveHighScore() { if (score > highScore) { highScore = score; localStorage.setItem('ultraInsaneTetrisHighScore', highScore); } }
        function updateHighScoreDisplay() { const hs = highScore.toString(); highScoreElement.textContent = hs; menuHighScoreElement.textContent = hs; gameOverHighScoreElement.textContent = hs; winHighScoreElement.textContent = hs; }

        // --- Input Handling ---
         function handleKeyDown(event) {
             const keyL = event.key.toLowerCase();

             // Pause/Resume is always available if game should be running
             if (keyL === 'p') {
                  // Only allow pause/resume if currently in game or already paused
                  if (currentScreen === 'game' || currentScreen === 'pauseOverlay') {
                      togglePause();
                      return; // Handled pause action
                  }
             }

             // Handle Hold - only in active game state
             if (keyL === 'c' && currentScreen === 'game' && !isPaused && !gameOver && !gameWon) {
                 playerHold();
                 // Redraw immediately after hold if game continues
                 if (!gameOver && !gameWon && !isPaused) draw();
                 return; // Handled hold action
             }

             // Ignore game input if not in active game state
             if (currentScreen !== 'game' || isPaused || gameOver || gameWon) return;

             let action = null;
             if (controlScheme === 'arrows') {
                 switch(event.key) {
                     case 'ArrowLeft': action = () => playerMove(-1); break;
                     case 'ArrowRight': action = () => playerMove(1); break;
                     case 'ArrowDown': action = () => playerDrop(); break; // Trigger score potentially
                     case 'ArrowUp': action = () => playerRotate(); break;
                     case ' ': action = () => hardDrop(); break; // Trigger score potentially
                 }
             } else { // WASD
                 switch(keyL) {
                     case 'a': action = () => playerMove(-1); break;
                     case 'd': action = () => playerMove(1); break;
                     case 's': action = () => playerDrop(); break; // Trigger score potentially
                     case 'w': action = () => playerRotate(); break;
                     case ' ': action = () => hardDrop(); break; // Trigger score potentially
                 }
             }

             if (action) {
                 event.preventDefault(); // Prevent default browser actions (scrolling etc.)
                 action(); // Execute the game action
                 // Redraw the board immediately after any movement/rotation/drop
                 if (!gameOver && !gameWon && !isPaused) {
                    draw();
                 }
             }
         }

        // --- Game State Management ---
        function togglePause() {
            // Can only pause/resume if the game isn't over
            if (gameOver || gameWon) return;

            isPaused = !isPaused;

            if (isPaused) {
                // Stop the game loop if it's running
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                showScreen('pauseOverlay');
            } else {
                // Resuming
                showScreen('game');
                // Restart the game loop only if it's not already running
                if (!animationFrameId) {
                    lastTime = performance.now(); // Reset timer to avoid large jump
                    gameLoop();
                }
            }
        }

        function exitToMainMenu() {
            // Stop loop regardless of current state
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            // Set states to prevent further game actions
            gameOver = true; // Treat exiting as game over
            gameWon = false;
            isPaused = false;
            currentPiece = null;
            particles = [];
            clearParticleCanvas();
            saveHighScore(); // Save score on exit
            showScreen('mainMenu');
        }

        function endGame() {
            // Guard clause: If already game over, do nothing more.
            if (gameOver && currentScreen === 'gameOver') return; // Prevent re-triggering if already on screen

            // Set the flag *first*
            gameOver = true;
            gameWon = false; // Ensure win is false
            isPaused = false; // Ensure not paused

            // Stop the game loop immediately
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            saveHighScore(); // Save score

            // Optional visual feedback
            gameContainer.style.transition = 'background-color 0.5s ease';
            gameContainer.style.backgroundColor = 'darkred';

            // Delay showing the game over screen
            setTimeout(() => {
                // Reset background color (optional, could be done when restarting)
                gameContainer.style.backgroundColor = 'rgba(20, 20, 40, 0.7)';
                // Ensure original transition is restored if needed
                gameContainer.style.transition = 'background-color 0.3s ease, box-shadow 0.3s ease';

                // Show the actual game over screen
                showScreen('gameOver');
            }, 600); // 600ms delay
        }

        function winGame() {
            // Guard clause
            if (gameWon) return;

            gameWon = true;
            gameOver = false; // Ensure game over is false
            isPaused = false;

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            saveHighScore();

            gameContainer.style.transition = 'background-color 0.5s ease, box-shadow 0.5s ease';
            gameContainer.style.backgroundColor = 'gold';
            gameContainer.style.boxShadow = '0 0 30px gold, 0 0 15px #fff inset';

            setTimeout(() => {
                gameContainer.style.backgroundColor = 'rgba(20, 20, 40, 0.7)';
                gameContainer.style.boxShadow = '0 0 40px rgba(0, 255, 255, 0.3), 0 0 20px rgba(255, 51, 204, 0.3)';
                showScreen('win');
            }, 1000);
        }

        // --- Event Listeners & Start ---
        function setupEventListeners() {
             startButton.addEventListener('click', startGameLoop);
             settingsButton.addEventListener('click', () => { showScreen('settings'); controlsArrowsRadio.checked = (controlScheme === 'arrows'); controlsWASDRadio.checked = (controlScheme === 'wasd'); });
             saveSettingsButton.addEventListener('click', () => { controlScheme = controlsWASDRadio.checked ? 'wasd' : 'arrows'; showScreen('mainMenu'); });
             restartButton.addEventListener('click', startGameLoop);
             playAgainWinButton.addEventListener('click', startGameLoop);
             backToMenuButtonGO.addEventListener('click', exitToMainMenu);
             backToMenuButtonWin.addEventListener('click', exitToMainMenu);
             exitToMenuPausedButton.addEventListener('click', exitToMainMenu);
             pauseButton.addEventListener('click', togglePause);
             resumeButton.addEventListener('click', togglePause);
             document.addEventListener('keydown', handleKeyDown);
        }

        function startGameLoop() {
            resetGame(); // Reset all game variables
            showScreen('game'); // Show the game area
            // Start the game loop only if it's not already running
            if (!animationFrameId) {
                lastTime = performance.now(); // Reset time measurement
                gameLoop();
            }
        }

        // --- Initial Setup ---
        window.onload = () => {
            initGame(); // Initialize canvases, load high score etc.
            setupEventListeners(); // Set up button clicks and keydown listeners
        };

    </script>
</body>
</html>